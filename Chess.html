<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Chess Game</title>

<style>
body {
    display: flex;
    justify-content: center;
    margin-top: 20px;
    font-family: Arial;
}

#board {
    display: grid;
    grid-template-columns: repeat(8, 60px);
    grid-template-rows: repeat(8, 60px);
    border: 2px solid black;
}

.square {
    width: 60px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 36px;
    cursor: pointer;
}

.light { background: #EEEED2; }
.dark { background: #769656; }

.highlight {
    outline: 3px solid yellow;
}
</style>
</head>

<body>

<div id="board"></div>

<script>
/* ---------- CHESS LOGIC ---------- */

class ChessPiece {
    constructor(name, color) {
        this.name = name;
        this.color = color;
    }
    symbol() {
        const symbols = {
            white: { king:"♔", queen:"♕", rook:"♖", bishop:"♗", knight:"♘", pawn:"♙" },
            black: { king:"♚", queen:"♛", rook:"♜", bishop:"♝", knight:"♞", pawn:"♟" }
        };
        return symbols[this.color][this.name];
    }
}

class ChessGame {
    constructor() {
        this.board = this.createBoard();
        this.turn = "white";
        this.gameOver = false;
        this.winner = null;
    }

    createBoard() {
        const b = Array.from({length:8},()=>Array(8).fill(null));

        b[0] = ["rook","knight","bishop","queen","king","bishop","knight","rook"]
            .map(p=>new ChessPiece(p,"black"));
        b[1] = Array(8).fill().map(()=>new ChessPiece("pawn","black"));
        b[6] = Array(8).fill().map(()=>new ChessPiece("pawn","white"));
        b[7] = ["rook","knight","bishop","queen","king","bishop","knight","rook"]
            .map(p=>new ChessPiece(p,"white"));

        return b;
    }

    validMoves(row,col) {
        const piece = this.board[row][col];
        if (!piece || piece.color !== this.turn) return [];
        const moves = [];

        const addLineMoves = (dirs) => {
            for (const [dr,dc] of dirs) {
                let r=row+dr, c=col+dc;
                while (r>=0&&r<8&&c>=0&&c<8) {
                    if (!this.board[r][c]) moves.push([r,c]);
                    else {
                        if (this.board[r][c].color !== piece.color) moves.push([r,c]);
                        break;
                    }
                    r+=dr; c+=dc;
                }
            }
        };

        if (piece.name==="pawn") {
            const dir = piece.color==="white" ? -1 : 1;
            const r=row+dir;
            if (r>=0&&r<8 && !this.board[r][col]) moves.push([r,col]);
            for (const dc of [-1,1]) {
                const c=col+dc;
                if (r>=0&&r<8&&c>=0&&c<8) {
                    const t=this.board[r][c];
                    if (t && t.color!==piece.color) moves.push([r,c]);
                }
            }
        }

        if (piece.name==="rook") addLineMoves([[1,0],[-1,0],[0,1],[0,-1]]);
        if (piece.name==="bishop") addLineMoves([[1,1],[1,-1],[-1,1],[-1,-1]]);
        if (piece.name==="queen") addLineMoves([[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]);

        if (piece.name==="knight") {
            for (const [dr,dc] of [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]) {
                const r=row+dr, c=col+dc;
                if (r>=0&&r<8&&c>=0&&c<8) {
                    if (!this.board[r][c] || this.board[r][c].color!==piece.color)
                        moves.push([r,c]);
                }
            }
        }

        if (piece.name==="king") {
            for (let dr=-1;dr<=1;dr++) {
                for (let dc=-1;dc<=1;dc++) {
                    if (dr||dc) {
                        const r=row+dr, c=col+dc;
                        if (r>=0&&r<8&&c>=0&&c<8) {
                            if (!this.board[r][c] || this.board[r][c].color!==piece.color)
                                moves.push([r,c]);
                        }
                    }
                }
            }
        }
        return moves;
    }

    move(r1,c1,r2,c2) {
        const target=this.board[r2][c2];
        this.board[r2][c2]=this.board[r1][c1];
        this.board[r1][c1]=null;

        if (target && target.name==="king") {
            this.gameOver=true;
            this.winner=this.turn;
        }
        this.turn=this.turn==="white"?"black":"white";
    }
}

/* ---------- GUI ---------- */

const boardDiv = document.getElementById("board");
const game = new ChessGame();
let selected=null;
let validMoves=[];

function drawBoard() {
    boardDiv.innerHTML="";
    for (let r=0;r<8;r++) {
        for (let c=0;c<8;c++) {
            const sq=document.createElement("div");
            sq.className="square "+((r+c)%2?"dark":"light");

            if (validMoves.some(m=>m[0]===r&&m[1]===c))
                sq.classList.add("highlight");

            const piece=game.board[r][c];
            if (piece) {
                sq.textContent=piece.symbol();
                sq.style.color=piece.color==="white"?"white":"black";
            }

            sq.onclick=()=>onClick(r,c);
            boardDiv.appendChild(sq);
        }
    }
}

function onClick(r,c) {
    if (game.gameOver) return;

    if (!selected) {
        const piece=game.board[r][c];
        if (piece && piece.color===game.turn) {
            selected=[r,c];
            validMoves=game.validMoves(r,c);
        }
    } else {
        if (validMoves.some(m=>m[0]===r&&m[1]===c)) {
            game.move(selected[0],selected[1],r,c);
            if (game.gameOver)
                alert(game.winner.toUpperCase()+" WINS!");
        }
        selected=null;
        validMoves=[];
    }
    drawBoard();
}

drawBoard();
</script>

</body>
</html>
